
<script>
//
// verovio_support_functions.html
//	Insert shared code for doing dynamic verovio examples in the documentation.
//	vim: ts=3
//	


// vrvToolkit stores the verovio toolkit interface.  When the page loads
// set up the vrvToolkit variable.

//var vrvToolkit;
// document.addEventListener("DOMContentLoaded", setupVerovio);




//////////////////////////////
//
// setupVerovio --  Retry every waittime milliseconds if
//    verovio is not yet ready.
//

function setupVerovio(waittime) {
	if (waittime <= 0) {
		waittime = 150;
	}
	if (!vrvToolkit) {
		vrvToolkit = new verovio.toolkit();
	}
	if (!vrvToolkit) {
		setTimeout(setupVerovio, waittime);
	}
}



//////////////////////////////
//
// initializeHumdrumText -- Copy the Humdrum text from the hidden location 
//    into the visible area for editing humdrum data.
//
//  id == the ID of the content that has the hidden Humdrum data.
//  options = the verovio options to render the music notation with.
//
//  There must be an element on the page (created with liquid templates)
//  which has the same id, but with "-humdrum" added to the end of the ID.
//
//  Returns true if the initialization was successful; otherwise, returns false.
//

function initializeHumdrumText(id, options) {
	var helement = document.querySelector("#" + id);
	if (!helement) {
		console.log("Could not find humdrum content element with id =", id);
		return false;
	}
	var newid = id + "-humdrum-pre";
	var target = document.querySelector("#" + newid);
	if (!target) {
		console.log("Error: could not find Humdrum target ID", id + "-humdrum-pre");
		return false;
	}
	// need to remove any initial blank space so that verovio can detect
	// Humdrum in "auto" mode.
	target.innerHTML = helement.textContent.replace(/^\s*/, "");
	target.addEventListener("keyup", function(event) { updateSvgDisplay(id, options); });
	target.addEventListener("keydown", function(event) { fixNewline(event, target)});

	// don't allow HTML content to be pasted in the Humdrum area
	target.addEventListener("paste", function(event) {
    	event.preventDefault();
    	var text = event.clipboardData.getData("text/plain");
    	document.execCommand("insertHTML", false, text);
	});

	return true;
}

//////////////////////////////
//
// fixNewline --  This function is necessary because newlines are not inserted
//    into a pre element when content
//

function fixNewline(event, target) {
	if (event.keyCode != 13) {
		// not the enter key, so ignore
		return;
	}
	if (!window.getSelection) {
		return;
	}
	var sel = window.getSelection();
	if (!sel) {
		return;
	}
	if (sel.rangeCount < 1) {
		return;
	}
	var range = sel.getRangeAt(0);
	var startNode     = range.startContainer;
	var startOffset   = range.startOffset;
	var boundaryRange = range.cloneRange();
	var startTextNode = document.createTextNode("");
	var endTextNode   = document.createTextNode("\n");
	boundaryRange.collapse(false);
	boundaryRange.insertNode(endTextNode);
	boundaryRange.setStart(startNode, startOffset);
	boundaryRange.collapse(true);
	boundaryRange.insertNode(startTextNode);
	// Reselect the original text
	//range.setStartAfter(startTextNode);
	//range.setEndBefore(endTextNode);
	range.setStartAfter(endTextNode);
	sel.removeAllRanges();
	sel.addRange(range);
	event.preventDefault();
}



//////////////////////////////
//
// udpateSvgDisplay --  When the Humdrum content changes, the SVG image
//     needs to be re-drawn.
//

function updateSvgDisplay(id, options) {
	if (!vrvToolkit) {
		VEROVIO_QUEUE.push( { id:id, options:options });
		// console.log("verovio not found, queuing job");
		return;
	}
	var targetid = id + "-svg";
	var selement = document.querySelector("#" + targetid);
	if (!selement) {
		console.log("Error: could not find svg target #" + targetid);
		return;
	}
	var humid = id + "-humdrum-pre";
	var helement = document.querySelector("#" + humid);
	if (!helement) {
		console.log("Error: could not find Humdrum source #" + humid);
		return;
	}
	var content = helement.textContent.replace(/^\s+/, "");
	var cleaned_options = cleanOptions(content, options);

	content = content.replace(/\n*$/,"\n");
	if (!`${options.filter}`.match(/^\s*$/)) {
		let filter = `!!!filter: ${options.filter}\n`;
		content += filter;
		delete cleaned_options.filter;
	}

	var svg = vrvToolkit.renderData(content, cleaned_options);

	selement.innerHTML = svg;
	// automatically set the height of the Humdrum element to be the
   // same size as the height of the SVG (barring limitations on the
	// min and max height given in CSS.
	helement.style.height = (selement.offsetHeight-40) + "px";
}



//////////////////////////////
//
// cleanOptions -- Remove options that will be processed interally from the data.
//

function cleanOptions(content, options) {
	var lines = content.match(/[^\r\n]+/g);
	var output = options;
	var setlist = [""];
	var optionsets = {};
	optionsets[""] = {};
	var i;
	for (i=0; i<lines.length; i++) {
		var matches = lines[i].match(/^!!!verovio([^\s]*):\s*(.*)\s*$/);
		if (!matches) {
			continue;
		}
		if (matches[1] == "-parameter-group") {
			setlist.push(matches[2]);
			continue;
		}
		var mm = matches[2].match(/^\s*([^\s]+)\s+(.*)\s*$/);
		if (!mm) {
			continue;
		}
		var m = matches[1].match(/^-([^\s]+)\s*$/);
		var set = "";
		if (m) {
			set = m[1];
		}
		if (typeof optionsets[set] === 'undefined') {
			optionsets[set] = {};
		}
		optionsets[set][mm[1]] = mm[2];
	}

	for (i=0; i<setlist.length; i++) {
		if (!optionsets[setlist[i]]) {
			continue;
		}
		var keys = Object.keys(optionsets[setlist[i]]);
		var j;
		var key;
		for (j=0; j<keys.length; j++) {
			if (typeof output[keys[j]] !== 'undefined') {
				delete output[keys[j]];
			}
		}
	}

	return output;
}


////////////////////////////////////////////////////////////////////////////
//
//  Base64 encode/decode: Fixes problems with atob and btoa with UTF-8 encoded text.
//
//  https://www.webtoolkit.info
//

var Base64 = {
	// private property
	_keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

	// public method for encoding
	encode : function (input) {
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		input = Base64._utf8_encode(input);

		while (i < input.length) {
			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}

			output = output +
			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
		}

		return output;
	},

	// public method for decoding
	decode : function (input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;
		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));

			if (i < input.length) {
				enc2 = this._keyStr.indexOf(input.charAt(i++));
			} else {
				enc2 = 64;
			}

			if (i < input.length) {
				enc3 = this._keyStr.indexOf(input.charAt(i++));
			} else {
				enc3 = 64;
			}

			if (i < input.length) {
				enc4 = this._keyStr.indexOf(input.charAt(i++));
			} else {
				enc4 = 64;
			}

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		output = Base64._utf8_decode(output);

		return output;

	},

	// private method for UTF-8 encoding
	_utf8_encode : function (string) {
		string = string.replace(/\r\n/g,"\n");
		var utftext = "";

		for (var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			} else if((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			} else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	},

	// private method for UTF-8 decoding
	_utf8_decode : function (utftext) {
		var string = "";
		var i = 0;
		var c = c1 = c2 = 0;

		while ( i < utftext.length ) {

			c = utftext.charCodeAt(i);

			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			} else if((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i+1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			} else {
				c2 = utftext.charCodeAt(i+1);
				c3 = utftext.charCodeAt(i+2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}
		}
		return string;
	}
}

</script>


